---
title: "Module 2: Output Parsers, Chains, Memory"
layout: post
---

Explore key components that allow LangChain to build sophisticated and dynamic workflows, such as chains that connect multiple language model calls or tools in sequence, parsers that interpret and structure raw outputs into usable formats, and memory that maintains conversational context across interactions to enable stateful agents. By the end, you will understand how these elements work together to create richer, multi-step applications that go beyond simple single-prompt interactions.


*The video below is a recap of what we covered in the previous module and also gives a brief introduction to the concepts of parsers and chains, which we will explore in more depth throughout this module.*

{% include embed.html url="https://www.youtube.com/embed/mrjq3lFz23s" %}

---

# **1. Output Parsers**

Output parsers in LangChain are essential tools that transform raw, unstructured responses from language models into clean, structured formats like strings, lists, dictionaries, or validated objects. This is important because raw text can often be unpredictable, inconsistent, or hard to process directly in code. By using output parsers, you ensure that outputs follow a predictable structure, making them easier to integrate into applications, trigger follow-up actions, or pass to downstream systems.

<div style="display: flex; align-items: flex-start; gap: 20px;">
  
  <div style="flex: 0 0 25%;">
    <a href="https://python.langchain.com/docs/concepts/output_parsers/" target="_blank">
      <img src="{{ '/assets/images/langchain_output_parsers.png' | relative_url }}" alt="Langchain Output Parsers"
           style="width: 100%; height: auto; border-radius: 8px;" />
    </a>
  </div>
  
  <div style="flex: 1;">
    <p>
      <em>
        Check the official documentation on output parsers and the different types of output parsers available, so you can understand their purpose and choose the right one for your specific use case.
      </em>
    </p>
  </div>

</div>

LangChain offers a variety of built-in output parsers, such as `StrOutputParser` for plain text, `CommaSeparatedListOutputParser` for lists, and `PydanticOutputParser` for structured data that follows defined schemas. These tools help reduce the risk of errors, improve automation reliability, and enforce data quality standards, especially when chaining multiple steps together or when interacting with external tools and APIs that require well-formed, consistent input.

*Check the video below to better understand what output parsers are and how they help improve the results you get from your models. The video covers key types such as the Structured Output Parser, CommaSeparatedList Output Parser, Pydantic Output Parser, Output Fixing Parser, and Retry Output Parser, with practical examples of when and how to use each.*

{% include embed.html url="https://www.youtube.com/embed/UVn2NroKQCw" %}


# **2. Understanding Chains**

Chains in LangChain are sequences of connected steps where the output of one component is passed as the input to the next, allowing you to build structured workflows with multiple LLM calls, tools, or processing stages.

For example, instead of relying on a single prompt to handle everything, you can design a chain where:

* Step 1 extracts key entities or topics from a user’s question
* Step 2 searches a knowledge base or external API using those entities
* Step 3 summarizes or reformats the retrieved results into a user-friendly response

This modular approach makes it easier to break down complex tasks into smaller, manageable parts, improves control over each stage of the process, and enables dynamic branching or conditional logic (for example, adjusting the chain’s path depending on the user’s input or the model’s response).

Chains are essential for building sophisticated applications like question-answering systems, multi-step reasoning agents, or pipelines that integrate LLMs with other data sources and tools. As we progress through the module, you will learn not only how to use built-in chain types but also how to create custom chains tailored to your own workflows.


https://medium.com/@shravankoninti/different-chain-types-using-langchain-89cacae6ad1f

https://hub.asimov.academy/tutorial/chains-do-langchain-o-que-sao-e-como-utiliza-las-para-criar-aplicacoes-com-encadeamento/

https://python.langchain.com/docs/concepts/lcel/

https://python.langchain.com/docs/how_to/parallel/

https://python.langchain.com/docs/how_to/sequence/



